package de.unipassau.rustyunit.metaheuristics.chromosome;

import static java.util.stream.Collectors.toCollection;

import java.util.ArrayList;
import java.util.List;
import java.util.Objects;
import java.util.function.Supplier;
import java.util.stream.Stream;

/**
 * A generator for populations of fixed size.
 *
 * @param <C> the type of chromosomes contained in the population
 * @author Sebastian Schweikl
 */
public class FixedSizePopulationGenerator<C extends Chromosome<C>> implements Supplier<List<C>> {

  /**
   * The generator with which to generate individual chromosomes.
   */
  private final ChromosomeGenerator<C> chromosomes;

  /**
   * The size of the population this generator creates.
   */
  private final int populationSize;

  /**
   * Creates a new population generator that uses the given chromosome generator to create
   * individual chromosomes of the population, while respecting the specified population size.
   *
   * @param chromosomeGenerator generator for individual chromosomes, {@code not null}
   * @param populationSize      size of the population generated by this population generator
   * @throws NullPointerException     if the chromosome generator is {@code null}
   * @throws IllegalArgumentException if the population size is negative
   */
  public FixedSizePopulationGenerator(
      final ChromosomeGenerator<C> chromosomeGenerator,
      final int populationSize) {
    Objects.requireNonNull(chromosomeGenerator);

    if (populationSize < 0) {
      throw new IllegalArgumentException("negative population size: " + populationSize);
    }

    this.chromosomes = chromosomeGenerator;
    this.populationSize = populationSize;
  }

  /**
   * Returns the fixed size of the populations generated by this generator.
   *
   * @return the size of a population
   */
  public int getPopulationSize() {
    return populationSize;
  }

  /**
   * Generates a new population of fixed size.
   *
   * @return the generated population
   */
  public List<C> get() {
    return Stream.generate(chromosomes)
        .limit(populationSize)
        .collect(toCollection(ArrayList::new));
  }
}